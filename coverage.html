
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>discovery: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hk9890/ai-config-manager/pkg/discovery/agents.go (0.0%)</option>
				
				<option value="file1">github.com/hk9890/ai-config-manager/pkg/discovery/commands.go (0.0%)</option>
				
				<option value="file2">github.com/hk9890/ai-config-manager/pkg/discovery/packages.go (75.5%)</option>
				
				<option value="file3">github.com/hk9890/ai-config-manager/pkg/discovery/skills.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package discovery

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/hk9890/ai-config-manager/pkg/resource"
)

const (
        // MaxRecursiveDepth is the maximum depth for recursive agent search
        MaxRecursiveDepth = 5
)

// DiscoverAgents discovers agent resources (single .md files) in a repository
// It searches in priority locations first, then falls back to recursive search
// if no agents are found.
//
// Priority locations:
//   - basePath/subpath/agents/
//   - basePath/subpath/.claude/agents/
//   - basePath/subpath/.opencode/agents/
//
// If no agents found in priority locations, performs recursive search (max depth 5)
// looking for .md files with valid agent frontmatter (description required).
//
// Returns deduplicated list of agents by agent name.
func DiscoverAgents(basePath string, subpath string) ([]*resource.Resource, error) <span class="cov0" title="0">{
        if basePath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("basePath cannot be empty")
        }</span>

        // Build full search path
        <span class="cov0" title="0">searchPath := basePath
        if subpath != "" </span><span class="cov0" title="0">{
                searchPath = filepath.Join(basePath, subpath)
        }</span>

        // Check if search path exists, but be lenient with subpaths
        <span class="cov0" title="0">searchPathInfo, searchPathErr := os.Stat(searchPath)

        // If searchPath doesn't exist but we have a subpath, try parent directories
        if searchPathErr != nil &amp;&amp; subpath != "" </span><span class="cov0" title="0">{
                currentPath := searchPath
                for </span><span class="cov0" title="0">{
                        parentPath := filepath.Dir(currentPath)
                        if parentPath == currentPath || parentPath == basePath </span><span class="cov0" title="0">{
                                searchPath = basePath
                                break</span>
                        }
                        <span class="cov0" title="0">if info, err := os.Stat(parentPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                searchPath = parentPath
                                break</span>
                        }
                        <span class="cov0" title="0">currentPath = parentPath</span>
                }
                // Re-check the new search path
                <span class="cov0" title="0">searchPathInfo, searchPathErr = os.Stat(searchPath)</span>
        }

        // Check if search path exists (after trying to find a valid parent)
        <span class="cov0" title="0">if searchPathErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search path does not exist: %w", searchPathErr)
        }</span>

        <span class="cov0" title="0">if !searchPathInfo.IsDir() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search path is not a directory: %s", searchPath)
        }</span>

        // Priority locations to search
        <span class="cov0" title="0">priorityLocations := []string{
                filepath.Join(searchPath, "agents"),
                filepath.Join(searchPath, ".claude", "agents"),
                filepath.Join(searchPath, ".opencode", "agents"),
        }

        // Try priority locations first
        agents := make([]*resource.Resource, 0)
        for _, location := range priorityLocations </span><span class="cov0" title="0">{
                found, err := discoverAgentsInDirectory(location, false)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but continue - directory might not exist
                        continue</span>
                }
                <span class="cov0" title="0">agents = append(agents, found...)</span>
        }

        // If no agents found in priority locations, do recursive search
        <span class="cov0" title="0">if len(agents) == 0 </span><span class="cov0" title="0">{
                found, err := discoverAgentsRecursive(searchPath, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("recursive search failed: %w", err)
                }</span>
                <span class="cov0" title="0">agents = append(agents, found...)</span>
        }

        // Deduplicate by agent name (keep first occurrence)
        <span class="cov0" title="0">agents = deduplicateAgents(agents)

        return agents, nil</span>
}

// discoverAgentsInDirectory finds agent .md files in a specific directory
// If recursive is true, it will search subdirectories up to MaxRecursiveDepth
func discoverAgentsInDirectory(dirPath string, recursive bool) ([]*resource.Resource, error) <span class="cov0" title="0">{
        // Check if directory exists
        info, err := os.Stat(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, nil // Directory doesn't exist, not an error
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to stat directory: %w", err)</span>
        }

        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("path is not a directory: %s", dirPath)
        }</span>

        <span class="cov0" title="0">agents := make([]*resource.Resource, 0)

        // Read directory entries
        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                entryPath := filepath.Join(dirPath, entry.Name())

                // Skip hidden directories and files (except .claude and .opencode)
                if strings.HasPrefix(entry.Name(), ".") &amp;&amp; !recursive </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If it's a .md file, try to load as agent
                <span class="cov0" title="0">if !entry.IsDir() &amp;&amp; filepath.Ext(entry.Name()) == ".md" </span><span class="cov0" title="0">{
                        agent, err := resource.LoadAgent(entryPath)
                        if err != nil </span><span class="cov0" title="0">{
                                // Skip invalid agents
                                continue</span>
                        }
                        <span class="cov0" title="0">agents = append(agents, agent)</span>
                }
        }

        <span class="cov0" title="0">return agents, nil</span>
}

// discoverAgentsRecursive performs recursive search for agent files
// up to MaxRecursiveDepth
func discoverAgentsRecursive(dirPath string, currentDepth int) ([]*resource.Resource, error) <span class="cov0" title="0">{
        // Check depth limit
        if currentDepth &gt; MaxRecursiveDepth </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Check if directory exists
        <span class="cov0" title="0">info, err := os.Stat(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to stat directory: %w", err)</span>
        }

        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">agents := make([]*resource.Resource, 0)

        // Find agents in current directory
        found, err := discoverAgentsInDirectory(dirPath, true)
        if err != nil </span><span class="cov0" title="0">{
                // Continue on error, might be permission issues
                return agents, nil
        }</span>
        <span class="cov0" title="0">agents = append(agents, found...)

        // Recursively search subdirectories
        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return agents, nil // Return what we have so far
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip common directories that typically don't contain agents
                <span class="cov0" title="0">if shouldSkipDirectory(entry.Name()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">subPath := filepath.Join(dirPath, entry.Name())
                subAgents, err := discoverAgentsRecursive(subPath, currentDepth+1)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue on error
                        continue</span>
                }
                <span class="cov0" title="0">agents = append(agents, subAgents...)</span>
        }

        <span class="cov0" title="0">return agents, nil</span>
}

// shouldSkipDirectory returns true if the directory should be skipped during recursive search
func shouldSkipDirectory(name string) bool <span class="cov0" title="0">{
        skipDirs := []string{
                "commands", // Commands are handled by command discovery
                "skills",   // Skills are handled by skill discovery
                "node_modules",
                ".git",
                ".svn",
                ".hg",
                "vendor",
                "build",
                "dist",
                "target",
                "bin",
                "obj",
                "__pycache__",
                ".pytest_cache",
                ".venv",
                "venv",
        }

        for _, skip := range skipDirs </span><span class="cov0" title="0">{
                if name == skip </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// deduplicateAgents removes duplicate agents, keeping the first occurrence
// Deduplication is by agent name
func deduplicateAgents(agents []*resource.Resource) []*resource.Resource <span class="cov0" title="0">{
        seen := make(map[string]bool)
        result := make([]*resource.Resource, 0, len(agents))

        for _, agent := range agents </span><span class="cov0" title="0">{
                if !seen[agent.Name] </span><span class="cov0" title="0">{
                        seen[agent.Name] = true
                        result = append(result, agent)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package discovery

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/hk9890/ai-config-manager/pkg/resource"
)

const maxDepth = 5

// DiscoverCommands discovers command resources (.md files) in a repository
// It searches in priority locations first, then falls back to recursive search
func DiscoverCommands(basePath string, subpath string) ([]*resource.Resource, error) <span class="cov0" title="0">{
        searchPath := basePath
        if subpath != "" </span><span class="cov0" title="0">{
                searchPath = filepath.Join(basePath, subpath)
        }</span>

        // Verify search path exists, but be lenient with subpaths
        <span class="cov0" title="0">searchPathInfo, searchPathErr := os.Stat(searchPath)

        // If searchPath doesn't exist but we have a subpath, try parent directories
        if searchPathErr != nil &amp;&amp; subpath != "" </span><span class="cov0" title="0">{
                currentPath := searchPath
                for </span><span class="cov0" title="0">{
                        parentPath := filepath.Dir(currentPath)
                        if parentPath == currentPath || parentPath == basePath </span><span class="cov0" title="0">{
                                searchPath = basePath
                                break</span>
                        }
                        <span class="cov0" title="0">if info, err := os.Stat(parentPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                searchPath = parentPath
                                break</span>
                        }
                        <span class="cov0" title="0">currentPath = parentPath</span>
                }
                // Re-check the new search path
                <span class="cov0" title="0">searchPathInfo, searchPathErr = os.Stat(searchPath)</span>
        }

        // Verify base path exists (after trying to find a valid parent)
        <span class="cov0" title="0">if searchPathErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("path does not exist: %w", searchPathErr)
        }</span>

        <span class="cov0" title="0">if !searchPathInfo.IsDir() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("path is not a directory: %s", searchPath)
        }</span>

        // Try priority locations first
        <span class="cov0" title="0">commands, err := searchPriorityLocations(searchPath)
        if err == nil &amp;&amp; len(commands) &gt; 0 </span><span class="cov0" title="0">{
                return deduplicateCommands(commands), nil
        }</span>

        // Fall back to recursive search (max depth 5)
        <span class="cov0" title="0">commands, err = recursiveSearchCommands(searchPath, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search for commands: %w", err)
        }</span>

        <span class="cov0" title="0">return deduplicateCommands(commands), nil</span>
}

// searchPriorityLocations searches standard command directories
func searchPriorityLocations(basePath string) ([]*resource.Resource, error) <span class="cov0" title="0">{
        priorityDirs := []string{
                filepath.Join(basePath, "commands"),
                filepath.Join(basePath, ".claude", "commands"),
                filepath.Join(basePath, ".opencode", "commands"),
        }

        var allCommands []*resource.Resource

        for _, dir := range priorityDirs </span><span class="cov0" title="0">{
                if _, err := os.Stat(dir); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Directory doesn't exist, skip
                }

                <span class="cov0" title="0">commands, err := searchDirectory(dir)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue searching other directories even if one fails
                        continue</span>
                }

                <span class="cov0" title="0">allCommands = append(allCommands, commands...)</span>
        }

        <span class="cov0" title="0">return allCommands, nil</span>
}

// recursiveSearchCommands performs a recursive search for command files
func recursiveSearchCommands(basePath string, depth int) ([]*resource.Resource, error) <span class="cov0" title="0">{
        if depth &gt; maxDepth </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var allCommands []*resource.Resource

        // Search current directory
        commands, err := searchDirectory(basePath)
        if err == nil </span><span class="cov0" title="0">{
                allCommands = append(allCommands, commands...)
        }</span>

        // Recursively search subdirectories
        <span class="cov0" title="0">entries, err := os.ReadDir(basePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip hidden directories (except .claude and .opencode which are handled in priority)
                <span class="cov0" title="0">if strings.HasPrefix(entry.Name(), ".") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip agents and skills directories (they're handled by their own discovery)
                <span class="cov0" title="0">if entry.Name() == "agents" || entry.Name() == "skills" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">subdirPath := filepath.Join(basePath, entry.Name())
                subCommands, err := recursiveSearchCommands(subdirPath, depth+1)
                if err == nil </span><span class="cov0" title="0">{
                        allCommands = append(allCommands, subCommands...)
                }</span>
        }

        <span class="cov0" title="0">return allCommands, nil</span>
}

// searchDirectory searches a single directory for command files
func searchDirectory(dir string) ([]*resource.Resource, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">var commands []*resource.Resource

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if it's a .md file
                <span class="cov0" title="0">if filepath.Ext(entry.Name()) != ".md" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Exclude special files
                <span class="cov0" title="0">if isExcludedFile(entry.Name()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filePath := filepath.Join(dir, entry.Name())

                // Try to load as command
                cmd, err := resource.LoadCommand(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        // Invalid command file, skip it
                        continue</span>
                }

                <span class="cov0" title="0">commands = append(commands, cmd)</span>
        }

        <span class="cov0" title="0">return commands, nil</span>
}

// isExcludedFile checks if a filename should be excluded from command discovery
func isExcludedFile(filename string) bool <span class="cov0" title="0">{
        excluded := []string{
                "SKILL.md",
                "README.md",
                "readme.md",
                "Readme.md",
                "REFERENCE.md",
                "reference.md",
                "Reference.md",
        }

        for _, excl := range excluded </span><span class="cov0" title="0">{
                if filename == excl </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// deduplicateCommands removes duplicate commands by name, keeping the first occurrence
func deduplicateCommands(commands []*resource.Resource) []*resource.Resource <span class="cov0" title="0">{
        seen := make(map[string]bool)
        var unique []*resource.Resource

        for _, cmd := range commands </span><span class="cov0" title="0">{
                if !seen[cmd.Name] </span><span class="cov0" title="0">{
                        seen[cmd.Name] = true
                        unique = append(unique, cmd)
                }</span>
        }

        <span class="cov0" title="0">return unique</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package discovery

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/hk9890/ai-config-manager/pkg/resource"
)

// DiscoverPackages discovers package resources (.package.json files) in a repository.
// It searches in the packages/ subdirectory for .package.json files.
//
// Parameters:
//   - basePath: The root directory to search in
//   - subpath: Optional subdirectory within basePath (usually empty for packages)
//
// Returns:
//   - Array of discovered packages
//   - Error if the path is invalid or search fails
//
// The function follows these rules:
//   - Only searches in packages/ subdirectory
//   - Loads files matching *.package.json pattern
//   - Skips invalid package files gracefully (continues searching)
//   - Returns empty array if packages/ directory doesn't exist
//   - Deduplicates by package name
func DiscoverPackages(basePath string, subpath string) ([]*resource.Package, error) <span class="cov8" title="1">{
        searchPath := basePath
        if subpath != "" </span><span class="cov8" title="1">{
                searchPath = filepath.Join(basePath, subpath)
        }</span>

        // Verify search path exists
        <span class="cov8" title="1">searchPathInfo, searchPathErr := os.Stat(searchPath)

        // If searchPath doesn't exist but we have a subpath, try parent directories
        if searchPathErr != nil &amp;&amp; subpath != "" </span><span class="cov0" title="0">{
                currentPath := searchPath
                for </span><span class="cov0" title="0">{
                        parentPath := filepath.Dir(currentPath)
                        if parentPath == currentPath || parentPath == basePath </span><span class="cov0" title="0">{
                                searchPath = basePath
                                break</span>
                        }
                        <span class="cov0" title="0">if info, err := os.Stat(parentPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                searchPath = parentPath
                                break</span>
                        }
                        <span class="cov0" title="0">currentPath = parentPath</span>
                }
                // Re-check the new search path
                <span class="cov0" title="0">searchPathInfo, searchPathErr = os.Stat(searchPath)</span>
        }

        // Verify base path exists (after trying to find a valid parent)
        <span class="cov8" title="1">if searchPathErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("path does not exist: %w", searchPathErr)
        }</span>

        <span class="cov8" title="1">if !searchPathInfo.IsDir() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("path is not a directory: %s", searchPath)
        }</span>

        // Check if packages/ directory exists
        <span class="cov8" title="1">packagesDir := filepath.Join(searchPath, "packages")
        if _, err := os.Stat(packagesDir); err != nil </span><span class="cov8" title="1">{
                // packages/ directory doesn't exist, return empty array
                return []*resource.Package{}, nil
        }</span>

        // Search for .package.json files in packages/ directory
        <span class="cov8" title="1">packages, err := searchPackagesDirectory(packagesDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search for packages: %w", err)
        }</span>

        <span class="cov8" title="1">return deduplicatePackages(packages), nil</span>
}

// searchPackagesDirectory searches a directory for package files
func searchPackagesDirectory(dir string) ([]*resource.Package, error) <span class="cov8" title="1">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov8" title="1">var packages []*resource.Package

        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if it's a .package.json file
                <span class="cov8" title="1">if !strings.HasSuffix(entry.Name(), ".package.json") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">filePath := filepath.Join(dir, entry.Name())

                // Try to load as package
                pkg, err := resource.LoadPackage(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        // Invalid package file, skip it
                        continue</span>
                }

                <span class="cov8" title="1">packages = append(packages, pkg)</span>
        }

        <span class="cov8" title="1">return packages, nil</span>
}

// deduplicatePackages removes duplicate packages by name, keeping the first occurrence
func deduplicatePackages(packages []*resource.Package) []*resource.Package <span class="cov8" title="1">{
        seen := make(map[string]bool)
        var unique []*resource.Package

        for _, pkg := range packages </span><span class="cov8" title="1">{
                if !seen[pkg.Name] </span><span class="cov8" title="1">{
                        seen[pkg.Name] = true
                        unique = append(unique, pkg)
                }</span>
        }

        <span class="cov8" title="1">return unique</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package discovery

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/hk9890/ai-config-manager/pkg/resource"
)

// SkillCandidate represents a skill discovered during search
type SkillCandidate struct {
        Path     string
        Resource *resource.Resource
}

// DiscoverSkills searches for skills following the priority-based algorithm
// It searches in standard locations first, then falls back to recursive search
func DiscoverSkills(basePath string, subpath string) ([]*resource.Resource, error) <span class="cov0" title="0">{
        // Build the initial search root
        searchRoot := basePath
        if subpath != "" </span><span class="cov0" title="0">{
                searchRoot = filepath.Join(basePath, subpath)
        }</span>

        // Check if searchRoot exists and is accessible
        <span class="cov0" title="0">searchRootInfo, searchRootErr := os.Stat(searchRoot)

        // If searchRoot exists, check if it's a skill directory
        if searchRootErr == nil &amp;&amp; searchRootInfo.IsDir() </span><span class="cov0" title="0">{
                if isSkillDir(searchRoot) </span><span class="cov0" title="0">{
                        skill, err := resource.LoadSkill(searchRoot)
                        if err == nil &amp;&amp; skill.Name != "" &amp;&amp; skill.Description != "" </span><span class="cov0" title="0">{
                                return []*resource.Resource{skill}, nil
                        }</span>
                }
        }

        // If searchRoot doesn't exist, try searching from immediate parent directory
        // This handles cases where the path might be slightly incorrect (e.g., typo in skill name)
        // but we don't want to fall back too far (which would mask real errors)
        <span class="cov0" title="0">if searchRootErr != nil </span><span class="cov0" title="0">{
                parentPath := filepath.Dir(searchRoot)
                // Only fall back if the parent is a valid, different directory
                if parentPath != searchRoot &amp;&amp; parentPath != "." &amp;&amp; parentPath != "/" </span><span class="cov0" title="0">{
                        if info, err := os.Stat(parentPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                                searchRoot = parentPath
                        }</span> else<span class="cov0" title="0"> {
                                // Parent doesn't exist either, this is a real error
                                return nil, fmt.Errorf("base path does not exist: %w", searchRootErr)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Can't fall back, this is a real error
                        return nil, fmt.Errorf("base path does not exist: %w", searchRootErr)
                }</span>
        }

        // Priority locations to search (relative to searchRoot)
        <span class="cov0" title="0">priorityLocations := []string{
                "skills",
                ".claude/skills",
                ".opencode/skills",
                ".github/skills",
                ".codex/skills",
                ".cursor/skills",
                ".goose/skills",
                ".kilocode/skills",
                ".kiro/skills",
                ".roo/skills",
                ".trae/skills",
                ".agents/skills",
                ".agent/skills",
        }

        // Search in priority locations
        candidates := make(map[string]*resource.Resource) // Map by name for deduplication
        for _, location := range priorityLocations </span><span class="cov0" title="0">{
                locationPath := filepath.Join(searchRoot, location)
                if skills := searchSkillsInDir(locationPath); len(skills) &gt; 0 </span><span class="cov0" title="0">{
                        for _, skill := range skills </span><span class="cov0" title="0">{
                                // First found wins (deduplication by name)
                                if _, exists := candidates[skill.Name]; !exists </span><span class="cov0" title="0">{
                                        candidates[skill.Name] = skill
                                }</span>
                        }
                }
        }

        // If we found skills, return them
        <span class="cov0" title="0">if len(candidates) &gt; 0 </span><span class="cov0" title="0">{
                return mapToSlice(candidates), nil
        }</span>

        // Fall back to recursive search (max depth 5)
        <span class="cov0" title="0">recursiveSkills, err := recursiveSearchSkills(searchRoot, 0)
        if err != nil </span><span class="cov0" title="0">{
                // If recursive search fails, just return what we have
                return mapToSlice(candidates), nil
        }</span>

        <span class="cov0" title="0">for _, skill := range recursiveSkills </span><span class="cov0" title="0">{
                if _, exists := candidates[skill.Name]; !exists </span><span class="cov0" title="0">{
                        candidates[skill.Name] = skill
                }</span>
        }

        <span class="cov0" title="0">return mapToSlice(candidates), nil</span>
}

// isSkillDir checks if a directory contains a SKILL.md file
func isSkillDir(path string) bool <span class="cov0" title="0">{
        skillMdPath := filepath.Join(path, "SKILL.md")
        info, err := os.Stat(skillMdPath)
        return err == nil &amp;&amp; !info.IsDir()
}</span>

// searchSkillsInDir searches for skills in a specific directory
// Returns all valid skills found (directories with SKILL.md)
func searchSkillsInDir(dirPath string) []*resource.Resource <span class="cov0" title="0">{
        var skills []*resource.Resource

        // Check if directory exists
        info, err := os.Stat(dirPath)
        if err != nil || !info.IsDir() </span><span class="cov0" title="0">{
                return skills
        }</span>

        // Read directory entries
        <span class="cov0" title="0">entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return skills
        }</span>

        // Check each subdirectory for SKILL.md
        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">skillPath := filepath.Join(dirPath, entry.Name())
                if !isSkillDir(skillPath) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try to load the skill
                <span class="cov0" title="0">skill, err := resource.LoadSkill(skillPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid skills
                }

                // Skip if name or description is missing
                <span class="cov0" title="0">if skill.Name == "" || skill.Description == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">skills = append(skills, skill)</span>
        }

        <span class="cov0" title="0">return skills</span>
}

// recursiveSearchSkills performs a recursive directory search for skills
// Limited to maxDepth (5) to prevent excessive searching
func recursiveSearchSkills(rootPath string, currentDepth int) ([]*resource.Resource, error) <span class="cov0" title="0">{
        var skills []*resource.Resource
        const maxDepth = 5

        // Stop if we've reached max depth
        if currentDepth &gt;= maxDepth </span><span class="cov0" title="0">{
                return skills, nil
        }</span>

        // Read directory entries
        <span class="cov0" title="0">entries, err := os.ReadDir(rootPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        // Check each entry
        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">entryPath := filepath.Join(rootPath, entry.Name())

                // Skip hidden directories (except those in our priority list)
                if len(entry.Name()) &gt; 0 &amp;&amp; entry.Name()[0] == '.' </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if this directory is a skill
                <span class="cov0" title="0">if isSkillDir(entryPath) </span><span class="cov0" title="0">{
                        skill, err := resource.LoadSkill(entryPath)
                        if err == nil &amp;&amp; skill.Name != "" &amp;&amp; skill.Description != "" </span><span class="cov0" title="0">{
                                skills = append(skills, skill)
                        }</span>
                        // Don't recurse into skill directories
                        <span class="cov0" title="0">continue</span>
                }

                // Recurse into subdirectory
                <span class="cov0" title="0">subSkills, err := recursiveSearchSkills(entryPath, currentDepth+1)
                if err == nil </span><span class="cov0" title="0">{
                        skills = append(skills, subSkills...)
                }</span>
        }

        <span class="cov0" title="0">return skills, nil</span>
}

// mapToSlice converts a map of resources to a slice
func mapToSlice(m map[string]*resource.Resource) []*resource.Resource <span class="cov0" title="0">{
        result := make([]*resource.Resource, 0, len(m))
        for _, v := range m </span><span class="cov0" title="0">{
                result = append(result, v)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
